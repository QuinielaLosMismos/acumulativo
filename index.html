/***********************
 * QUINIELA LOS MISMOS
 * Code.gs (ESTABLE + Reemplazo + PadrÃ³n + Admin switches + Cierre automÃ¡tico)
 ***********************/
const SPREADSHEET_ID = '1KEZajlAhdP6kVflxSY5sMjArNwnvjx6Fnz75DUkTMgU';
const SHEET_CONFIG   = 'CONFIG';
const SHEET_RESP     = 'RESPUESTAS';
const MAX_PARTIDOS   = 13;

// ðŸŽ¨ Colores (formato RESPUESTAS)
const COLOR_ACIERTO  = '#c6efce'; // verde claro
const COLOR_GANADOR  = '#fff2cc'; // amarillo claro
const COLOR_LIMPIO   = '#ffffff'; // blanco

/* ========= Helpers ========= */
function ss_(){ return SpreadsheetApp.openById(SPREADSHEET_ID); }

function json_(obj){
  return ContentService.createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}

function col_(headers, name){
  const idx = headers.indexOf(name);
  if (idx < 0) throw new Error(`Falta columna: ${name}`);
  return idx + 1;
}

function parseMoney_(v){
  return Number(String(v||'').replace(/[^0-9.]/g,'')) || 0;
}

// âœ… SOLO L/E/V (cualquier otra cosa = vacÃ­o)
function normLEV_(v){
  const s = String(v ?? '').trim().toUpperCase();
  if (s === 'L' || s === 'E' || s === 'V') return s;
  return '';
}

// Nombre: MAYÃšSCULAS + sin acentos + espacios normalizados
function sanitizeNombreServer_(v){
  let s = String(v ?? '').trim();
  s = s.normalize('NFD').replace(/[\u0300-\u036f]/g,''); // sin acentos
  s = s.replace(/\s+/g,' ').toUpperCase();
  return s;
}

// Para comparar (case/acentos/espacios)
function normName_(v){
  let s = String(v ?? '').trim();
  s = s.normalize('NFD').replace(/[\u0300-\u036f]/g,''); // sin acentos
  s = s.replace(/\s+/g,' ').toLowerCase();
  return s;
}

// Interpreta jornada aunque venga como "Jornada 2" o "2"
function parseJornada_(v){
  const s = String(v ?? '').trim();
  if (!s) return null;
  const n = Number(s);
  if (Number.isFinite(n)) return n;
  const m = s.match(/(\d+)/);
  return m ? Number(m[1]) : null;
}

/* ========= CONFIG: read/write ========= */
function readConfig_(){
  const sh = ss_().getSheetByName(SHEET_CONFIG);
  const lastRow = Math.max(sh.getLastRow(), 15);
  const grid = sh.getRange(1,1,lastRow,3).getValues();

  const kv = {};
  grid.forEach(r=>{
    if (r[0]) kv[String(r[0]).toLowerCase().trim()] = r[1];
  });

  const subtitulo = String(kv['subtitulo'] || '');
  const m = subtitulo.match(/(\d+)/);
  const jornada = m ? Number(m[1]) : null;

  const partidos = [];
  const resultados = [];

  // Partidos desde fila 10: A=Local, B=Visitante, C=Resultado
  for (let r=10; r<=lastRow; r++){
    const local  = String(sh.getRange(r,1).getValue() || '').trim();
    const visita = String(sh.getRange(r,2).getValue() || '').trim();
    const res    = normLEV_(sh.getRange(r,3).getValue());

    if (!local && !visita) continue;

    partidos.push({ local, visita });
    resultados.push(res);
  }

  const allowNew     = String(kv['allownew'] || '').toUpperCase();       // SI/NO
  const closeEnabled = String(kv['closeenabled'] || '').toUpperCase();   // SI/NO
  const closeAt      = String(kv['closeat'] || '');                      // "YYYY-MM-DD HH:MM"
  const adminKey     = String(kv['adminkey'] || '');                     // opcional

  return {
    activo: String(kv['activo'] || '').toUpperCase(),
    jornada,
    premioSemanal: parseMoney_(kv['premio semanal']),
    partidos,
    resultados,

    // âœ… nuevos
    allowNew: (allowNew === 'SI' ? 'SI' : 'NO'),
    closeEnabled: (closeEnabled === 'SI' ? 'SI' : 'NO'),
    closeAt,
    adminKey,
  };
}

// Escribe/crea llave en CONFIG (col A=key, col B=value)
function writeConfigKV_(key, value){
  const sh = ss_().getSheetByName(SHEET_CONFIG);
  const lastRow = Math.max(sh.getLastRow(), 15);
  const rng = sh.getRange(1,1,lastRow,2).getValues(); // A:B
  const k = String(key || '').toLowerCase().trim();

  for (let i=0; i<rng.length; i++){
    const a = String(rng[i][0] || '').toLowerCase().trim();
    if (a === k){
      sh.getRange(i+1, 2).setValue(value);
      return;
    }
  }
  // no existe: agregar al final
  sh.appendRow([k, value]);
}

/* ========= RESPUESTAS: headers + fila 2 ========= */
function syncRespuestas_(){
  const sh = ss_().getSheetByName(SHEET_RESP);

  // âœ… orden: TelÃ©fono antes de Nombre (como lo querÃ­as)
  const headers = [
    'Jornada',          // A
    'Timestamp',        // B
    'TelÃ©fono',         // C
    'Nombre',           // D
    ...Array.from({length: MAX_PARTIDOS}, (_,i)=>`p${i+1}`), // E-Q
    'Aciertos',         // R
    'NumGanadores',     // S
    'PremioPorGanador', // T
  ];

  sh.getRange(1,1,1,headers.length).setValues([headers]);
  sh.setFrozenRows(1);

  if (sh.getLastRow() < 2) sh.insertRowAfter(1);

  const cfg = readConfig_();
  const row2 = new Array(headers.length).fill('');

  const start = headers.indexOf('p1');
  cfg.partidos.forEach((p,i)=>{
    if (i < MAX_PARTIDOS) row2[start + i] = `${p.local} vs ${p.visita}`;
  });

  sh.getRange(2,1,1,headers.length).setValues([row2]);
}

/* ========= Trigger (CONFIG) ========= */
function onEditConfig_(e){
  if (e.range.getSheet().getName() !== SHEET_CONFIG) return;
  syncRespuestas_();
}

function instalarTriggerConfig(){
  ScriptApp.getProjectTriggers().forEach(t=>{
    if (t.getHandlerFunction() === 'onEditConfig_') ScriptApp.deleteTrigger(t);
  });

  ScriptApp.newTrigger('onEditConfig_')
    .forSpreadsheet(SPREADSHEET_ID)
    .onEdit()
    .create();

  syncRespuestas_();
}

/* ========= Buscar fila por nombre+jornada (para reemplazar) ========= */
function filaPorNombreYJornada_(nombre, jornada){
  const sh = ss_().getSheetByName(SHEET_RESP);
  const lastRow = sh.getLastRow();
  if (lastRow < 3) return null;

  const headers = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];
  const cNom = col_(headers,'Nombre');
  const cJor = col_(headers,'Jornada');

  const nombres = sh.getRange(3, cNom, lastRow-2, 1).getValues().flat();
  const jornadas = sh.getRange(3, cJor, lastRow-2, 1).getValues().flat();

  const targetName = normName_(nombre);
  const targetJ = Number(jornada);

  for (let i=0; i<nombres.length; i++){
    if (normName_(nombres[i]) !== targetName) continue;
    const j = parseJornada_(jornadas[i]);
    if (j === targetJ) return 3 + i;
  }
  return null;
}

/* ========= PadrÃ³n: existe en una o varias jornadas ========= */
function nombreExisteEnJornadas_(nombre, jornadasPermitidas){
  const sh = ss_().getSheetByName(SHEET_RESP);
  const lastRow = sh.getLastRow();
  if (lastRow < 3) return false;

  const setJ = new Set((jornadasPermitidas || []).map(n=>Number(n)));
  const headers = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];
  const cNom = col_(headers,'Nombre');
  const cJor = col_(headers,'Jornada');

  const target = normName_(nombre);
  const nombres = sh.getRange(3, cNom, lastRow-2, 1).getValues().flat();
  const jornadas = sh.getRange(3, cJor, lastRow-2, 1).getValues().flat();

  for (let i=0; i<nombres.length; i++){
    const j = parseJornada_(jornadas[i]);
    if (!Number.isFinite(j)) continue;
    if (!setJ.has(j)) continue;
    if (normName_(nombres[i]) === target) return true;
  }
  return false;
}

/* ========= Cierre automÃ¡tico ========= */
function parseCloseAt_(s){
  const v = String(s || '').trim();
  if (!v) return null;

  // Soporta: "YYYY-MM-DD HH:MM"
  const m = v.match(/^(\d{4}-\d{2}-\d{2})[ T](\d{2}:\d{2})/);
  if (m){
    const iso = `${m[1]}T${m[2]}:00`;
    const d = new Date(iso); // en Apps Script usa TZ del script/hoja
    return isNaN(d.getTime()) ? null : d;
  }
  // ISO directo
  const d = new Date(v);
  return isNaN(d.getTime()) ? null : d;
}

function registroAbierto_(cfg){
  if (String(cfg.activo || '').toUpperCase() !== 'SI') return false;

  if (String(cfg.closeEnabled || '').toUpperCase() === 'SI'){
    const d = parseCloseAt_(cfg.closeAt);
    if (d){
      const now = new Date();
      if (now.getTime() >= d.getTime()) return false;
    }
  }
  return true;
}

/* ========= WebApp ========= */
function doGet(e){
  try{
    if (e?.parameter?.action !== 'getConfig') return json_({ ok:true });

    syncRespuestas_();

    const cfg = readConfig_();
    // devolver solo lo necesario al frontend
    return json_({
      ok:true,
      activo: cfg.activo,
      jornada: cfg.jornada,
      premioSemanal: cfg.premioSemanal,
      partidos: cfg.partidos,

      // âœ… admin toggles + cierre
      allowNew: cfg.allowNew,
      closeEnabled: cfg.closeEnabled,
      closeAt: cfg.closeAt,
    });
  }catch(err){
    return json_({ ok:false, message:String(err) });
  }
}

function doPost(e){
  try{
    const data = JSON.parse(e.postData.contents || '{}');

    // âœ… ADMIN SET (desde el panel del HTML)
    if (String(data.action || '') === 'adminSet'){
      const cfg = readConfig_();

      // seguridad opcional: si hay adminKey en CONFIG, exigirlo
      const requiredKey = String(cfg.adminKey || '').trim();
      if (requiredKey){
        const got = String(data.adminKey || '').trim();
        if (!got || got !== requiredKey){
          return json_({ ok:false, message:'AdminKey invÃ¡lida.' });
        }
      }

      const allowNew = String(data.allowNew || '').toUpperCase() === 'SI' ? 'SI' : 'NO';
      const closeEnabled = String(data.closeEnabled || '').toUpperCase() === 'SI' ? 'SI' : 'NO';
      const closeAt = String(data.closeAt || '').trim();

      writeConfigKV_('allownew', allowNew);
      writeConfigKV_('closeenabled', closeEnabled);
      writeConfigKV_('closeat', closeAt);

      // refrescar fila 2 si cambiaste algo relevante
      syncRespuestas_();

      return json_({ ok:true });
    }

    // ===== EnvÃ­o normal de quiniela =====
    const nombreRaw = String(data.nombre || '').trim();
    const tel       = String(data.telefono || '').trim();
    const replace   = data.replace === true;

    const nombre = sanitizeNombreServer_(nombreRaw);

    if (!nombre) return json_({ ok:false, message:'Falta nombre' });
    if (!tel)    return json_({ ok:false, message:'Falta telÃ©fono' });

    const cfg = readConfig_();
    if (!cfg.jornada) return json_({ ok:false, message:'Jornada no definida' });

    // âœ… cierre automÃ¡tico / activo
    if (!registroAbierto_(cfg)){
      return json_({ ok:false, message:'Registro cerrado' });
    }

    // âœ… padrÃ³n (solo si NO se permiten nuevos)
    const allowNew = String(cfg.allowNew || '').toUpperCase() === 'SI';
    if (!allowNew){
      if (cfg.jornada === 2){
        // J2: deben existir en J1
        if (!nombreExisteEnJornadas_(nombre, [1])){
          return json_({
            ok:false,
            message:'Este nombre no estÃ¡ registrado desde la Jornada 1. Usa el mismo nombre con el que participaste la primera vez.'
          });
        }
      } else if (cfg.jornada >= 3){
        // J3+: deben existir en J1 o J2
        if (!nombreExisteEnJornadas_(nombre, [1,2])){
          return json_({
            ok:false,
            message:'Este nombre no estÃ¡ registrado desde la Jornada 1 o 2. Usa el mismo nombre con el que participaste al inicio.'
          });
        }
      }
      // J1: siempre permite (no entra aquÃ­)
    }

    // validaciÃ³n picks
    if (!Array.isArray(data.partidos) || data.partidos.length !== cfg.partidos.length){
      return json_({ ok:false, message:'Selecciones incompletas' });
    }

    const sh = ss_().getSheetByName(SHEET_RESP);
    const headers = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];

    const fila = filaPorNombreYJornada_(nombre, cfg.jornada);

    // existe y no pidiÃ³ reemplazar â†’ preguntar
    if (fila && !replace){
      return json_({
        ok:false,
        code:'DUPLICATE',
        message:'Ya existe una quiniela con este nombre en esta jornada. Â¿Quieres reemplazarla?'
      });
    }

    const row = new Array(headers.length).fill('');
    row[col_(headers,'Jornada')-1]    = cfg.jornada;
    row[col_(headers,'Timestamp')-1]  = new Date();
    row[col_(headers,'Nombre')-1]     = nombre;
    row[col_(headers,'TelÃ©fono')-1]   = tel;

    data.partidos.forEach((p,i)=>{
      if (i < MAX_PARTIDOS){
        row[col_(headers,`p${i+1}`)-1] = normLEV_(p.pronostico);
      }
    });

    if (fila){
      sh.getRange(fila, 1, 1, row.length).setValues([row]);
    } else {
      sh.appendRow(row);
    }

    return json_({ ok:true });

  }catch(err){
    return json_({ ok:false, message:String(err) });
  }
}

/* ========= Formato visual: aciertos + ganadores (solo jornada actual) ========= */
function aplicarFormatoJornada_(cfg){
  const sh = ss_().getSheetByName(SHEET_RESP);
  const lastRow = sh.getLastRow();
  const lastCol = sh.getLastColumn();
  if (lastRow < 3) return;

  const values = sh.getRange(1,1,lastRow,lastCol).getValues();
  const h = values[0];

  const cJ  = col_(h,'Jornada');
  const cA  = col_(h,'Aciertos');
  const cP1 = col_(h,'p1');

  const numPicks = Math.min(cfg.partidos.length, MAX_PARTIDOS);

  // max aciertos jornada actual
  let maxA = -1;
  for (let r=2; r<values.length; r++){
    const j = parseJornada_(values[r][cJ-1]);
    if (j === null || j !== cfg.jornada) continue;
    const ac = Number(values[r][cA-1]) || 0;
    if (ac > maxA) maxA = ac;
  }
  if (maxA < 0) maxA = 0;

  const dataRows = lastRow - 2;
  const rangoDatos = sh.getRange(3,1,dataRows,lastCol);
  const bgs = rangoDatos.getBackgrounds();

  for (let rr=0; rr<dataRows; rr++){
    const r = rr + 2; // Ã­ndice en values
    const j = parseJornada_(values[r][cJ-1]);
    if (j === null || j !== cfg.jornada) continue;

    const ac = Number(values[r][cA-1]) || 0;
    const esGanador = (ac === maxA);

    // limpiar fila de esa jornada
    for (let c=0; c<lastCol; c++) bgs[rr][c] = COLOR_LIMPIO;

    // resaltar ganadores (fila completa)
    if (esGanador){
      for (let c=0; c<lastCol; c++) bgs[rr][c] = COLOR_GANADOR;
    }

    // aciertos en verde (ganen o no)
    for (let i=0; i<numPicks; i++){
      const pick = normLEV_(values[r][(cP1-1)+i]);
      const res  = normLEV_(cfg.resultados[i]);
      if (pick && res && pick === res){
        bgs[rr][(cP1-1)+i] = COLOR_ACIERTO;
      }
    }
  }

  rangoDatos.setBackgrounds(bgs);
}

/* ========= Calificar jornada actual ========= */
function calificarJornadaActual(){
  const cfg = readConfig_();
  if (!cfg.jornada) throw new Error('Jornada no definida en CONFIG (Subtitulo).');

  const sh = ss_().getSheetByName(SHEET_RESP);
  const values = sh.getDataRange().getValues();
  const h = values[0];

  const cJ  = col_(h,'Jornada');
  const cA  = col_(h,'Aciertos');
  const cNG = col_(h,'NumGanadores');
  const cPP = col_(h,'PremioPorGanador');

  let maxA = -1;
  const filas = [];

  for (let r=2; r<values.length; r++){ // desde fila 3
    const j = parseJornada_(values[r][cJ-1]);
    if (j === null || j !== cfg.jornada) continue;

    let ac = 0;
    for (let i=0; i<cfg.partidos.length && i<MAX_PARTIDOS; i++){
      const pick = normLEV_(values[r][col_(h,`p${i+1}`)-1]);
      const res  = normLEV_(cfg.resultados[i]);
      if (pick && res && pick === res) ac++;
    }

    values[r][cA-1] = ac;
    filas.push(r);
    if (ac > maxA) maxA = ac;
  }

  const ganadores = filas.filter(r => Number(values[r][cA-1]) === maxA);
  const porGanador = ganadores.length ? (cfg.premioSemanal / ganadores.length) : 0;

  // âœ… solo llenar NG/PP en filas ganadoras (las demÃ¡s quedan en blanco)
  filas.forEach(r=>{
    if (Number(values[r][cA-1]) === maxA){
      values[r][cNG-1] = ganadores.length;
      values[r][cPP-1] = porGanador;
    } else {
      values[r][cNG-1] = '';
      values[r][cPP-1] = '';
    }
  });

  sh.getRange(1,1,values.length,values[0].length).setValues(values);

  // ordenar por jornada desc y aciertos desc
  if (sh.getLastRow() > 2){
    sh.getRange(3,1,sh.getLastRow()-2,sh.getLastColumn())
      .sort([{column:cJ, ascending:false}, {column:cA, ascending:false}]);
  }

  // formato visual
  aplicarFormatoJornada_(cfg);
}
